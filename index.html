<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Beyond Delegation: Orchestrating Controlled Agentic Systems</title>
  <style>
    :root {
      /* Day Mode - Sepia/Warm theme */
      --day-background: #faf8f2;
      --day-surface: #f5f3ed;
      --day-card: #fefcf6;
      --day-text-primary: #3c2f1f;
      --day-text-secondary: #5a4835;
      --day-text-muted: #8b7355;
      --day-border: #d9d1c1;
      --day-header-bg: #3c2f1f;
      --day-header-text: #f5f3ed;

      /* Night Mode - Soft dark theme */
      --night-background: #1a1a1a;
      --night-surface: #2d2d2d;
      --night-card: #252525;
      --night-text-primary: #e8e6e0;
      --night-text-secondary: #d0cdc4;
      --night-text-muted: #a39d8b;
      --night-border: #404040;
      --night-header-bg: #1a1a1a;
      --night-header-text: #e8e6e0;

      --base-font-size: clamp(19px, 1.8vw, 21px);
      --font-scale-sm: calc(var(--base-font-size) * 1.1);
      --font-scale-md: calc(var(--base-font-size) * 1.25);
      --font-scale-lg: calc(var(--base-font-size) * 1.45);
      --font-scale-xl: calc(var(--base-font-size) * 1.75);
      --diagram-font-size: clamp(1rem, 0.9vw, 1.35rem);
      --diagram-width: clamp(280px, 60vw, 740px);
    }

    [data-theme="day"], :root {
      --background: var(--day-background);
      --surface: var(--day-surface);
      --card: var(--day-card);
      --text-primary: var(--day-text-primary);
      --text-secondary: var(--day-text-secondary);
      --text-muted: var(--day-text-muted);
      --border: var(--day-border);
      --header-bg: var(--day-header-bg);
      --header-text: var(--day-header-text);
    }

    [data-theme="night"] {
      --background: var(--night-background);
      --surface: var(--night-surface);
      --card: var(--night-card);
      --text-primary: var(--night-text-primary);
      --text-secondary: var(--night-text-secondary);
      --text-muted: var(--night-text-muted);
      --border: var(--night-border);
      --header-bg: var(--night-header-bg);
      --header-text: var(--night-header-text);
    }

    * {
      box-sizing: border-box;
      transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
    }

    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "SF Pro Text", Roboto, "Helvetica Neue", Arial, sans-serif;
      line-height: 1.65;
      background-color: var(--background);
      color: var(--text-secondary);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      font-size: var(--base-font-size);
    }

    .theme-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 50px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-primary);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .theme-toggle:hover {
      background: var(--surface);
    }

    .lang-toggle {
      position: fixed;
      top: 20px;
      right: 140px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 50px;
      padding: 8px 16px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-primary);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .lang-toggle:hover {
      background: var(--surface);
    }

    @media (max-width: 480px) {
      .lang-toggle {
        top: 15px;
        right: 120px;
        padding: 6px 12px;
        font-size: 13px;
      }
      .theme-toggle {
        top: 15px;
        right: 15px;
        padding: 6px 12px;
        font-size: 13px;
      }
    }

    .container {
      margin: clamp(1rem, 4vw, 3rem) 5%;
    }

    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 3px 20px rgba(0,0,0,0.06);
    }

    header {
      text-align: center;
      padding: clamp(1.25rem, 3vw, 2rem) clamp(1rem, 3vw, 1.5rem) 0;
    }

    header h3 {
      display: block;
      width: 100%;
      margin: 0 0 1rem;
      font-size: var(--base-font-size);
      font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background-color: var(--header-bg);
      color: var(--header-text);
      padding: 0.6rem 0.8rem;
      border: 1px solid var(--border);
      border-radius: 6px;
      text-align: left;
      overflow-x: auto;
      white-space: nowrap;
      font-weight: 400;
    }

    article {
      padding: 1rem clamp(1rem, 3vw, 1.75rem) clamp(1.5rem, 4vw, 2.25rem);
    }

    h1, h2, h3 {
      color: var(--text-primary);
      line-height: 1.3;
      font-weight: 600;
    }

    h1 {
      font-size: var(--font-scale-xl);
      margin: 0 0 0.5rem;
      letter-spacing: -0.02em;
    }

    h2 {
      font-size: var(--font-scale-lg);
      margin: 1.75rem 0 0.75rem;
      letter-spacing: -0.01em;
    }

    h3 {
      font-size: var(--font-scale-md);
    }

    .subtitle {
      font-size: var(--font-scale-sm);
      color: var(--text-muted);
      margin: 0 0 1.25rem;
      font-weight: 400;
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: clamp(1.25rem, 4vw, 2rem) 0;
    }

    p {
      margin: 0.8rem 0;
      color: var(--text-secondary);
      font-size: var(--base-font-size);
      line-height: 1.7;
    }

    ul, ol {
      margin: 0.6rem 0 1rem 1.4rem;
      padding: 0;
    }

    li {
      margin: 0.4rem 0;
      color: var(--text-secondary);
      line-height: 1.7;
      font-size: var(--base-font-size);
    }

    .blockquote {
      background: var(--surface);
      border-left: 4px solid var(--text-primary);
      padding: 1rem 1.25rem;
      margin: 1rem 0;
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 0.95rem;
      font-style: italic;
      line-height: 1.6;
    }

    code {
      background: var(--surface);
      padding: 0.15em 0.4em;
      border-radius: 3px;
      font-size: 0.9em;
      font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Monaco, Consolas, "Courier New", monospace;
      color: var(--text-primary);
    }

    pre {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.9rem 0.85rem;
      overflow-x: auto;
      font-size: 0.75rem;
      line-height: 1.35;
      color: var(--text-secondary);
      font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Monaco, Consolas, monospace;
      margin: 0.8rem 0;
      white-space: pre;
    }

    .footer {
      text-align: center;
      padding: 1rem 1rem 1.25rem;
      color: var(--text-muted);
      font-size: 0.85rem;
      border-top: 1px dashed var(--border);
    }

    a {
      color: var(--text-primary);
      text-decoration: underline;
      text-decoration-thickness: 0.08em;
      text-underline-offset: 0.22em;
    }

    /* Chapter layout */
    .chapter {
      margin-top: 1.5rem;
    }

    .chapter-layout {
      display: flex;
      gap: clamp(1rem, 2vw, 2rem);
      align-items: stretch;
      margin-top: 0.75rem;
    }

    .chapter-text {
      flex: 3;
      min-width: 0;
    }

    .chapter-diagram {
      flex: 2.8;
      min-width: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .chapter-diagram.pre-split {
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 0.5rem;
    }

    .diagram-block {
      width: 100%;
      display: flex;
      justify-content: center;
    }

    .diagram-block.tiers {
      margin-top: 17.2rem;
    }

    .diagram-block.flow {
      margin-top: 8.4rem;
    }

    .chapter-diagram pre,
    .diagram-centered pre {
      margin: 0;
      font-size: var(--diagram-font-size);
      line-height: 1.35;
      width: min(100%, var(--diagram-width));
      overflow-x: hidden;
    }

    @media (max-width: 960px) {
      .chapter-layout {
        flex-direction: column;
      }

      .chapter-diagram {
        order: 2;
      }
    }
  </style>
</head>
<body data-theme="day" data-lang="es">
  <button class="theme-toggle" id="theme-btn">
    <span class="theme-icon">â˜€ï¸</span>
    <span class="theme-text">Modo DÃ­a</span>
  </button>

  <button class="lang-toggle" id="lang-btn">
    <span class="lang-icon">ğŸŒ</span>
    <span class="lang-text">EN</span>
  </button>

  <div class="container">
    <div class="card">
      <header>
        <h3 id="page-title" data-text-en="jaguilar@ai-context-ops ~/gaia-ops % : cat /agents/workflow.md" data-text-es="jaguilar@ai-context-ops ~/gaia-ops % : cat /agents/workflow.md">jaguilar@ai-context-ops ~/gaia-ops % : cat /agents/workflow.md</h3>
      </header>
      <article lang="es" data-lang-section="es">
        <h1>MÃ¡s allÃ¡ de la delegaciÃ³n: Orquestando Sistemas AgÃ©nticos Controlados</h1>
        <p class="subtitle">CÃ³mo pasÃ© de delegar la ejecuciÃ³n de comandos con IA a diseÃ±ar un sistema agÃ©ntico completo con orquestaciÃ³n, contexto y seguridad en capas.</p>

        <p><strong>Autor:</strong> Jorge Aguilar Â· <strong>Fecha:</strong> Noviembre 2025 Â· <strong>ConexiÃ³n:</strong> ContinuaciÃ³n de "Context Design &amp; Agentic Deployment"</p>

        <hr />

        <p>En mi artÃ­culo anterior, compartÃ­ cÃ³mo Spec-Kitâ€”un framework de planificaciÃ³n estructuradaâ€”junto con 5 agentes especializados, lograron desplegar cuatro aplicaciones desde cero de manera agÃ©ntica. Aplicaciones contenedorizadas, infraestructura en IaC verificada y despliegues GitOps. El sistema entregÃ³.</p>

        <p>Pero yo estuve ahÃ­ todo el tiempo: monitoreando cada paso, interviniendo cuando el agente se desviaba, confirmando cada operaciÃ³n. Usaba IA, sÃ­, pero seguÃ­a siendo el operador manual. MÃ¡s que un sistema autÃ³nomo, era como construir un robot que necesita que lo lleves de la mano.</p>

        <p>AhÃ­ apareciÃ³ la disyuntiva. Por un lado, generaba valor real: aplicaciones desplegadas, entregas cumplidas. Por el otro, cada sesiÃ³n me revelaba algo nuevo sobre arquitectura de agentes, <em>context engineering</em> y orquestaciÃ³n inteligente. Â¿Estaba realmente automatizando o solo delegando comandos? Entre investigaciones profundas, auditorÃ­as y ese loop recursivo para mejorar continuamente el sistema, era difÃ­cil medirlo. IntuÃ­a, sin embargo, que el siguiente paso no era â€œmÃ¡s agentesâ€, sino <strong>mÃ¡s orquestaciÃ³n y mÃ¡s control</strong>. De eso trata este artÃ­culo.</p>

        <hr />

        <!-- CapÃ­tulo 1 -->
        <section class="chapter" id="cap-1">
          <div class="chapter-layout">
            <div class="chapter-text">
              <h2>CapÃ­tulo 1: Arquitectura</h2>
              <h3>Recursive Self-Improvement en AcciÃ³n</h3>
              <div class="blockquote">En ingenierÃ­a de software, un objeto que hace todo termina no haciendo nada bien. Â¿Por quÃ© deberÃ­a ser diferente con agentes?</div>
              <p>El problema era mÃ¡s profundo que solo dividir responsabilidades. No bastaba con crear subagentes especializados y aislarlos. Necesitaba un orquestador: alguien que supiera el workflow completo, que entendiera cÃ³mo y cuÃ¡ndo llamar a cada especialista. Un director de orquesta que conociera la partitura.</p>
              <p>AhÃ­ empezÃ³ un proceso intenso de investigaciÃ³n: sesiones de auditorÃ­a y mejora del propio sistema con Claude Code, Codex y otros LLMs. Me apoyÃ© en bÃºsquedas profundas guiadas por IA para detectar patrones de orquestaciÃ³n y workflow, estudiar ingenierÃ­a de contexto y sistemas multiâ€‘agente, analizar repositorios de GitHub y aprender de experiencias reales en Reddit y artÃ­culos tÃ©cnicos. <em>Recursive selfâ€‘improvement</em> en acciÃ³n.</p>
              <p>Esta investigaciÃ³n me llevÃ³ a una arquitectura completamente diferente. Si querÃ­a ir mÃ¡s allÃ¡ de delegar tareas, necesitaba poner al orquestador en el centro.</p>
              <h3>Los 5 especialistas y su razÃ³n de existir</h3>
              <ul>
                <li><strong>terraform-architect</strong>: Infraestructura como cÃ³digo (recursos GCP/AWS).</li>
                <li><strong>gitops-operator</strong>: Deployments Kubernetes/Flux.</li>
                <li><strong>gcp-troubleshooter</strong>: DiagnÃ³sticos GCP (solo lectura).</li>
                <li><strong>aws-troubleshooter</strong>: DiagnÃ³sticos AWS (solo lectura).</li>
                <li><strong>devops-developer</strong>: Build/test/CIâ€‘CD en la capa de aplicaciÃ³n.</li>
                <li><strong>claude-code (el orquestador)</strong>: Lee <code>project-context.json</code>, genera <em>context contracts</em>, ejecuta el routing semÃ¡ntico, aplica <em>security tiers</em>, gestiona <em>approval gates</em> y mantiene la fuente de verdad actualizada.</li>
              </ul>
            </div>
            <div class="chapter-diagram">
              <pre>
User Request
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CLAUDE CODE (Orquestador)         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
       Reads  â†’ project-context.json
       Builds â†’ context contract payload
                â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚terraform â”‚ gitops   â”‚  gcp     â”‚  aws     â”‚ devops   â”‚
  â”‚architect â”‚ operator â”‚troublesh.â”‚troublesh.â”‚developer â”‚
  â””â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”˜
       â”‚          â”‚          â”‚          â”‚          â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
 Analyze â†’ Plan â†’ Ask User â†’ Execute â†’ Verify â†’ Report
                â”‚
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Live Environment              â”‚
â”‚ GKE | Cloud SQL/RDS | VPCs | K8s | Git reposâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              </pre>
            </div>
          </div>
        </section>

        <!-- CapÃ­tulo 2 -->
        <section class="chapter" id="cap-2">
          <div class="chapter-layout">
            <div class="chapter-text">
              <h2>CapÃ­tulo 2: Project Context â€“ La Fuente de Verdad</h2>
              <div class="blockquote">La arquitectura estaba tomando forma. Pero quedaba una pieza fundamental: Â¿sobre QUÃ‰ trabajan estos agentes?</div>
              <p>Tener 5 agentes y un orquestador no resolvÃ­a todo. HabÃ­a otro problema arquitectÃ³nico: el sistema debÃ­a ser agnÃ³stico. No podÃ­a <em>hardcodear</em> configuraciones de un solo cliente en los prompts de los agentes. Necesitaba un framework reutilizable que funcionara con mÃºltiples proyectos, mÃºltiples clientes, mÃºltiples stacks tecnolÃ³gicos. Cada agente debÃ­a poder trabajar en cualquier contexto sin reescribir su â€œcÃ³digo mentalâ€.</p>
              <p>La soluciÃ³n fue externalizar todo el conocimiento del proyecto. AhÃ­ naciÃ³ <strong>Project Context</strong>.</p>
              <h3>Project Context: un archivo, toda la verdad</h3>
              <p><code>project-context.json</code> es la fuente de verdad (SSOT) de cada proyecto. Un archivo por cliente/proyecto. Contiene todo lo que el sistema necesita saber:</p>
              <ul>
                <li><strong>project_details:</strong> Nombre, cliente, descripciÃ³n, stack tecnolÃ³gico.</li>
                <li><strong>terraform_infrastructure:</strong> MÃ³dulos, variables, <em>outputs</em>, estado de recursos.</li>
                <li><strong>gitops_configuration:</strong> Repositorios Git, estructura Kustomize, <em>overlays</em>.</li>
                <li><strong>cluster_details:</strong> Clusters GKE/EKS, namespaces, recursos, pods.</li>
                <li><strong>application_services:</strong> APIs, frontends, puertos, estados, dependencias.</li>
                <li><strong>operational_guidelines:</strong> Reglas del proyecto (no usar X, siempre validar Y).</li>
              </ul>
              <p>Este archivo es el cerebro del sistema y crece con cada deploy: cuando <code>gitops-operator</code> despliega un nuevo servicio o <code>terraform-architect</code> crea una base de datos, ambos actualizan <code>project-context.json</code>. El archivo evoluciona con el proyecto.</p>
            </div>
            <div class="chapter-diagram">
              <pre>
Project Context (SSOT)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           project-context.json              â”‚
â”‚ project_details                             â”‚
â”‚ terraform_infrastructure                    â”‚
â”‚ gitops_configuration                        â”‚
â”‚ cluster_details                             â”‚
â”‚ application_services                        â”‚
â”‚ operational_guidelines                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â†“
[Paso 1] Orquestador interpreta la peticiÃ³n
[Paso 2] Elige agente adecuado
[Paso 3] Carga project-context.json
[Paso 4] Filtra solo lo relevante para ese agente
[Paso 5] EnvÃ­a contexto reducido al agente
              </pre>
            </div>
          </div>
        </section>

        <!-- CapÃ­tulo 3 -->
        <section class="chapter" id="cap-3">
          <div class="chapter-layout">
            <div class="chapter-text">
              <h2>CapÃ­tulo 3: Inteligencia Controlada</h2>
              <h3>Contexto preciso, routing inteligente, guardrails firmes</h3>
              <div class="blockquote">Los agentes hacen el trabajo; el orquestador decide el orden, el contexto y los lÃ­mites.</div>
              <p>En este capÃ­tulo describo las piezas que le dan esa capacidad al sistema: el router que interpreta la intenciÃ³n del usuario, el proveedor de contexto que traduce <code>project-context.json</code> en lo justo y necesario para cada agente, y el <em>approval gate</em> que pone al humano en las decisiones crÃ­ticas, todo dentro de un workflow de seis fases.</p>

              <h3>1. Agent Routing: de lenguaje natural a decisiÃ³n precisa</h3>
              <p><strong>El problema:</strong> No querÃ­a forzar al usuario a usar palabras reservadas o lenguaje tÃ©cnico preciso. Si alguien dice â€œterraformâ€, obvio: invocar <code>terraform-architect</code>. Pero Â¿quÃ© pasa con â€œNecesito una base de datosâ€, â€œRevisa el clusterâ€, â€œEl servicio no respondeâ€?</p>
              <p><strong>Primera versiÃ³n:</strong> keywords simples. Si detectaba â€œterraformâ€ â†’ <code>terraform-architect</code>. Si detectaba â€œkubernetesâ€ â†’ <code>gitops-operator</code>. FuncionÃ³â€¦ hasta que no.</p>
              <p><strong>VersiÃ³n 2 â€“ anÃ¡lisis de intenciÃ³n:</strong> No solo palabras exactas, sino sinÃ³nimos y conceptos relacionados. â€œStorageâ€ se mapea a infraestructura. â€œLogsâ€ sugiere recursos compartidos. AnÃ¡lisis semÃ¡ntico usando embeddings para comparar la query con descripciones de cada agente.</p>

              <h3>2. Context Provider: el corazÃ³n del sistema</h3>
              <p><strong>El problema:</strong> cada agente necesita contexto diferente, pero <code>project-context.json</code> es grande (30K+ tokens). Enviar todo el archivo a cada agente era ineficiente, costoso y confuso.</p>
              <div class="blockquote">Mucho contexto puede ser perjudicial para la correcta ejecuciÃ³n de tareas, incluso aunque el agente parta de un contexto â€œlimpioâ€.</div>
              <p><strong>SoluciÃ³n:</strong> <em>Context Contracts</em>, el API de los agentes. Cada agente declara quÃ© campos necesita; el orquestador lee el contrato, extrae solo esas secciones del projectâ€‘context y construye un payload optimizado. El agente recibe exactamente lo que necesita. Nada mÃ¡s.</p>

              <h3>3. Approval Gate: el humano siempre en el loop</h3>
              <p><strong>FilosofÃ­a:</strong> â€œTrust but verifyâ€. Los agentes pueden planear, analizar y proponer, pero solo humanos pueden aprobar operaciones crÃ­ticas.</p>
              <div class="blockquote"><strong>Â¿QuÃ© es una operaciÃ³n crÃ­tica?</strong> Tier T3: operaciones que modifican estado en producciÃ³n y no son fÃ¡cilmente reversibles.</div>
            </div>
            <div class="chapter-diagram">
              <pre>
User Query
    â†“
[Fase 1: Routing]
    Agent Router â†’ elige agente
    â†“
[Fase 2: Contexto]
    Context Provider â†’ payload reducido
    â†“
[Fase 3: Planning]
    Agente â†’ Realization Package
    â†“ HALT
[Fase 4: Approval Gate]
    Resumen en lenguaje humano
    AskUserQuestion â†’ Aprobar / Rechazar / Otro
    â”œâ”€ Approved? â†’ continuar
    â””â”€ Rejected? â†’ HALT
    â†“
[Fase 5: RealizaciÃ³n]
    Execute + Verify
    â†“
[Fase 6: State Update]
    update project-context.json
    update tasks.md
    report next steps
              </pre>
            </div>
          </div>
        </section>

        <!-- CapÃ­tulo 4 -->
        <section class="chapter" id="cap-4">
          <div class="chapter-layout">
            <div class="chapter-text">
              <h2>CapÃ­tulo 4: Seguridad en Capas</h2>
              <h3>Settings y permissions: security tiers y hooks</h3>
              <div class="blockquote">La automatizaciÃ³n rara vez se detiene por falta de capacidad; casi siempre se detiene donde se acaba nuestra confianza.</div>
              <p>El problema no era la automatizaciÃ³n en sÃ­. Era que estaba creando fricciÃ³n innecesaria donde no la necesitaba. Un workflow predecible requiere dos pilares simultÃ¡neos:</p>
              <p><strong>Agilidad</strong>, donde el riesgo es nulo (queries, validaciones).</p> 
              <p><strong>Control</strong>, donde el riesgo es irreversible (deployments, deletions).</p>
              <p>Sin esta discriminaciÃ³n, terminas con ruido o peligro. <strong>Â¿SoluciÃ³n?</strong></p>

              <h3>1. Security Tiers (T0â€“T3)</h3>
              <p>ClasifiquÃ© todas las operaciones en cuatro niveles de riesgo: <strong>T0</strong> lecturas, <strong>T1</strong> validaciones, <strong>T2</strong> cambios locales/dryâ€‘run y <strong>T3</strong> operaciones que escriben en entornos reales y requieren Approval Gate.</p>

              <h3>2. Hooks: los guardianes del sistema</h3>
              <p><strong>pre_tool_use.py:</strong> Intercepta todos los comandos ante de ejcutarse y decide si es seguro antes de ejecutarlo.</p> 
              <p><strong>post_tool_use.py:</strong> Registra quÃ© pasÃ³ despuÃ©s de ejecutar el comando.</p>
              <p><strong>subagent_stop.py:</strong> Cada vez que un agente cierra una sesiÃ³n, genera un reporte completo.</p>

              <h3>3. Settings: Allow, Ask, Deny</h3>
              <p>Con los tiers y los hooks en su lugar, el orquestador por fin estaba blindado: cualquier comando pasaba por un filtro antes de tocar un entorno real. Era momento de que los agentes dejaran de solo ejecutar comandos por mÃ­; era momento de delegarles tareas completas. Para eso tuve que ir a la raÃ­z: editar el archivo <code>.claude/settings.json</code>.</p>
              <p>AllÃ­ defino cÃ³mo reacciona Claude Code ante cada comando que nace del prompt: <strong>Deny</strong> marca lo que nunca debe ejecutarse, <strong>Ask</strong> detiene el flujo y me pide una confirmaciÃ³n explÃ­cita para operaciones sensibles y <strong>Allow</strong> deja pasar lecturas y acciones seguras sin fricciÃ³n.</p>
              <p>El resultado es simple: la velocidad del sistema ya no estÃ¡ limitada por lo que los agentes pueden hacer, sino por lo que yo decido permitir. Cuando mi confianza cambia, no reescribo todo el sistema; ajusto los settings.</p>
            </div>
            <div class="chapter-diagram pre-split">
              <div class="diagram-block tiers">
                <pre>
Security Tiers
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Tierâ”‚ Tipo          â”‚ Ejemplo rÃ¡pido              â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ T0 â”‚ Readâ€‘Only     â”‚ get, show, status           â”‚
â”‚ T1 â”‚ Validation    â”‚ validate, lint, --dryâ€‘run   â”‚
â”‚ T2 â”‚ Dryâ€‘Run/Local â”‚ plan, edits locales         â”‚
â”‚ T3 â”‚ Write Ops     â”‚ apply, push, deploy         â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                </pre>
              </div>
              <div class="diagram-block flow">
                <pre>
Flujo de ejecuciÃ³n
User prompt
    â†“
Settings (Allow / Ask / Deny)
    â†“
pre_tool_use.py   (seguridad)
    â†“
Bash / comando
    â†“
post_tool_use.py  (audit log)
    â†“
subagent_stop.py  (reporte de sesiÃ³n)
                </pre>
              </div>
            </div>
          </div>
        </section>

        <hr />

        <!-- SÃ­ntesis -->
        <section class="chapter" id="cap-6">
          <h2>CapÃ­tulo 5: Reflexiones, SÃ­ntesis y el Camino Adelante</h2>
          <h3>QuÃ© Funciona, QuÃ© No, y Por QuÃ© Importa</h3>
          <p>Las herramientas estÃ¡n. Los guardrails estÃ¡n. El sistema funciona. Pero construirlo me enseÃ±Ã³ mÃ¡s sobre sistemas que sobre comandos individuales.</p>

          <p>Si algo he aprendido en toda esta locura es que esta nueva tecnologÃ­a no va de escribir mÃ¡s software, sino de <strong>diseÃ±ar comportamientos</strong>: sistemas que tomen decisiones con contexto, con guardrails y con un humano que entiende por quÃ© confÃ­a en ellos. Cada iteraciÃ³n me hizo preguntarme menos â€œquÃ© cÃ³digo escribirâ€ y mÃ¡s â€œquÃ© decisiones quiero que tome el sistema, con quÃ© contexto y bajo quÃ© lÃ­mitesâ€.</p>

          <h3>Principios que me llevo</h3>
          <ul>
            <li><strong>La IA no reemplaza al humano, lo amplifica.</strong> Me permite explorar mÃ¡s caminos en menos tiempo, pero esa amplificaciÃ³n solo funciona si mantengo el mismo rigor que tendrÃ­a revisando el trabajo de un equipo humano.</li>
            <li><strong>Contexto no es un dump de informaciÃ³n.</strong> Es decidir quÃ© necesita saber cada agente, ni mÃ¡s ni menos. <code>project-context.json</code>, los contracts y el Context Provider existen para que los agentes trabajen con contexto Ãºtil, no con ruido.</li>
            <li><strong>Un workflow claro vale mÃ¡s que â€œmÃ¡s inteligenciaâ€.</strong> Las seis fases (routing, contexto, planning, approval, realizaciÃ³n, actualizaciÃ³n) importan mÃ¡s que tener un modelo mÃ¡s grande. Sin fases claras, el sistema se vuelve impredecible.</li>
            <li><strong>La seguridad es parte de la arquitectura, no un parche al final.</strong> Los tiers T0â€“T3, los hooks y los settings Allow/Ask/Deny no son â€œdetalle de implementaciÃ³nâ€: son la base para poder confiar en un sistema que ejecuta comandos reales en entornos reales.</li>
            <li><strong>No hay versiÃ³n final, solo versiones suficientemente buenas para aprender algo nuevo.</strong> El sistema cambia con cada uso. Lo importante no es â€œcerrarloâ€, sino tener la capacidad de observarlo, medirlo y rediseÃ±arlo sin miedo.</li>
          </ul>

          <h3>Â¿QuÃ© sigue?</h3>
          <p>El sistema ya estÃ¡ empaquetado como NPM y listo para <code>npx</code>, pero todavÃ­a no publicado. Lo que viene ahora se resume en tres frentes:</p>
          <ul>
            <li><strong>Profundizar en Clarify (Phase 0):</strong> mejorar la detecciÃ³n de ambigÃ¼edad y las preguntas automÃ¡ticas que guÃ­an al usuario.</li>
            <li><strong>Replantear la planificaciÃ³n (Specâ€‘Kit y mÃ¡s allÃ¡):</strong> revisar cÃ³mo nacen las tareas y los planes para ajustarlos mejor al workflow de seis fases y al uso real de agentes.</li>
            <li><strong>Hacer visible la gestiÃ³n de tareas:</strong> explorar si la mejor opciÃ³n es integrar JIRA/Linear u optar por un sistema propio que hable el mismo idioma que los agentes.</li>
          </ul>

        </section>
      </article>
      <article lang="en" data-lang-section="en" hidden>
        <h1>Beyond Delegation: Orchestrating Controlled Agentic Systems</h1>
        <p class="subtitle">How I moved from delegating command execution with AI to designing a complete agentic system with orchestration, context, and layered security.</p>

        <p><strong>Author:</strong> Jorge Aguilar Â· <strong>Date:</strong> November 2025 Â· <strong>Connection:</strong> Continuation of "Context Design &amp; Agentic Deployment"</p>

        <hr />

        <p>In my previous article, I shared how Spec-Kitâ€”a structured planning frameworkâ€”along with 5 specialized agents, successfully deployed four applications from scratch in an agentic aproach. Containerized applications, verified IaC infrastructure, and GitOps deployments. The system delivered.</p>

        <p>But I was there the whole time: monitoring every step, intervening when the agent deviated, confirming every operation. I was using AI, yes, but I was still the manual operator. More than an autonomous system, it was like building a robot that still needed hand-holding.</p>

        <p>That's where the dilemma appeared. On one hand, I was generating real value: deployed applications, fulfilled deliveries. On the other, each session revealed something new about agent architecture, <em>context engineering</em>, and intelligent orchestration. Was I really automating or just delegating commands? Between deep research, audits, and that recursive loop to continuously improve the system, it was hard to measure. I intuited, however, that the next step wasn't "more agents," but <strong>more orchestration and more control</strong>. That's what this article is about.</p>

        <hr />

        <!-- Chapter 1 -->
        <section class="chapter" id="cap-1">
          <div class="chapter-layout">
            <div class="chapter-text">
              <h2>Chapter 1: Architecture</h2>
              <h3>Recursive Self-Improvement in Action</h3>
              <div class="blockquote">In software engineering, an object that does everything ends up doing nothing well. Why should it be different with agents?</div>
              <p>The problem was deeper than just dividing responsibilities. Creating specialized subagents and isolating them wasn't enough. I needed an orchestrator: someone who knew the complete workflow, who understood how and when to call each specialist. A conductor who knew the score.</p>
              <p>That's when an intense research process began: audit sessions and improvement of the system itself with Claude Code, Codex, and other LLMs. I relied on deep AI-guided searches to detect orchestration and workflow patterns, study context engineering and multi-agent systems, analyze GitHub repositories, and learn from real experiences on Reddit and technical articles. <em>Recursive selfâ€‘improvement</em> in action.</p>
              <p>This research led me to a completely different architecture. If I wanted to go beyond delegating tasks, I needed to put the orchestrator at the center.</p>
              <h3>The 5 specialists and their reason for being</h3>
              <ul>
                <li><strong>terraform-architect</strong>: Infrastructure as code (GCP/AWS resources).</li>
                <li><strong>gitops-operator</strong>: Kubernetes/Flux deployments.</li>
                <li><strong>gcp-troubleshooter</strong>: GCP diagnostics (read-only).</li>
                <li><strong>aws-troubleshooter</strong>: AWS diagnostics (read-only).</li>
                <li><strong>devops-developer</strong>: Build/test/CIâ€‘CD at the application layer.</li>
                <li><strong>claude-code (the orchestrator)</strong>: Reads <code>project-context.json</code>, generates <em>context contracts</em>, executes semantic routing, applies <em>security tiers</em>, manages <em>approval gates</em>, and keeps the source of truth updated.</li>
              </ul>
            </div>
            <div class="chapter-diagram">
              <pre>
User Request
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CLAUDE CODE (Orchestrator)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
       Reads  â†’ project-context.json
       Builds â†’ context contract payload
                â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚terraform â”‚ gitops   â”‚  gcp     â”‚  aws     â”‚ devops   â”‚
  â”‚architect â”‚ operator â”‚troublesh.â”‚troublesh.â”‚developer â”‚
  â””â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”˜
       â”‚          â”‚          â”‚          â”‚          â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
 Analyze â†’ Plan â†’ Ask User â†’ Execute â†’ Verify â†’ Report
                â”‚
                â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Live Environment              â”‚
â”‚ GKE | Cloud SQL/RDS | VPCs | K8s | Git reposâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              </pre>
            </div>
          </div>
        </section>

        <!-- Chapter 2 -->
        <section class="chapter" id="cap-2">
          <div class="chapter-layout">
            <div class="chapter-text">
              <h2>Chapter 2: Project Context â€“ The Source of Truth</h2>
              <div class="blockquote">The architecture was taking shape. But a fundamental piece remained: what do these agents work ON?</div>
              <p>Having 5 agents and an orchestrator didn't solve everything. There was another architectural problem: the system had to be agnostic. I couldn't <em>hardcode</em> configurations from a single client in the agent prompts. I needed a reusable framework that worked with multiple projects, multiple clients, multiple technology stacks. Each agent had to be able to work in any context without rewriting its "mental code."</p>
              <p>The solution was to externalize all project knowledge. That's how <strong>Project Context</strong> was born.</p>
              <h3>Project Context: one file, all the truth</h3>
              <p><code>project-context.json</code> is the single source of truth (SSOT) for each project. One file per client/project. It contains everything the system needs to know:</p>
              <ul>
                <li><strong>project_details:</strong> Name, client, description, technology stack.</li>
                <li><strong>terraform_infrastructure:</strong> Modules, variables, <em>outputs</em>, resource state.</li>
                <li><strong>gitops_configuration:</strong> Git repositories, Kustomize structure, <em>overlays</em>.</li>
                <li><strong>cluster_details:</strong> GKE/EKS clusters, namespaces, resources, pods.</li>
                <li><strong>application_services:</strong> APIs, frontends, ports, states, dependencies.</li>
                <li><strong>operational_guidelines:</strong> Project rules (don't use X, always validate Y).</li>
              </ul>
              <p>This file is the brain of the system and grows with each deploy: when <code>gitops-operator</code> deploys a new service or <code>terraform-architect</code> creates a database, both update <code>project-context.json</code>. The file evolves with the project.</p>
            </div>
            <div class="chapter-diagram">
              <pre>
Project Context (SSOT)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           project-context.json              â”‚
â”‚ project_details                             â”‚
â”‚ terraform_infrastructure                    â”‚
â”‚ gitops_configuration                        â”‚
â”‚ cluster_details                             â”‚
â”‚ application_services                        â”‚
â”‚ operational_guidelines                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â†“
[Step 1] Orchestrator interprets the request
[Step 2] Chooses appropriate agent
[Step 3] Loads project-context.json
[Step 4] Filters only what's relevant for that agent
[Step 5] Sends reduced context to agent
              </pre>
            </div>
          </div>
        </section>

        <!-- Chapter 3 -->
        <section class="chapter" id="cap-3">
          <div class="chapter-layout">
            <div class="chapter-text">
              <h2>Chapter 3: Controlled Intelligence</h2>
              <h3>Precise context, intelligent routing, firm guardrails</h3>
              <div class="blockquote">Agents do the work; the orchestrator decides the order, context, and limits.</div>
              <p>In this chapter I describe the pieces that give the system this capability: the router that interprets user intent, the context provider that translates <code>project-context.json</code> into just what's needed for each agent, and the <em>approval gate</em> that puts humans in critical decisions, all within a six-phase workflow.</p>

              <h3>1. Agent Routing: from natural language to precise decision</h3>
              <p><strong>The problem:</strong> I didn't want to force users to use reserved words or precise technical language. If someone says "terraform," obvious: invoke <code>terraform-architect</code>. But what about "I need a database," "Check the cluster," "The service isn't responding"?</p>
              <p><strong>First version:</strong> simple keywords. If it detected "terraform" â†’ <code>terraform-architect</code>. If it detected "kubernetes" â†’ <code>gitops-operator</code>. It worked... until it didn't.</p>
              <p><strong>Version 2 â€“ intent analysis:</strong> Not just exact words, but synonyms and related concepts. "Storage" maps to infrastructure. "Logs" suggests shared resources. Semantic analysis using embeddings to compare the query with each agent's descriptions.</p>

              <h3>2. Context Provider: the heart of the system</h3>
              <p><strong>The problem:</strong> each agent needs different context, but <code>project-context.json</code> is large (30K+ tokens). Sending the entire file to each agent was inefficient, costly, and confusing.</p>
              <div class="blockquote">Too much context can be harmful to correct task execution, even if the agent starts from a "clean" context.</div>
              <p><strong>Solution:</strong> <em>Context Contracts</em>, the agents' API. Each agent declares what fields it needs; the orchestrator reads the contract, extracts only those sections from the projectâ€‘context, and builds an optimized payload. The agent receives exactly what it needs. Nothing more.</p>

              <h3>3. Approval Gate: humans always in the loop</h3>
              <p><strong>Philosophy:</strong> "Trust but verify". Agents can plan, analyze, and propose, but only humans can approve critical operations.</p>
              <div class="blockquote"><strong>What is a critical operation?</strong> Tier T3: operations that modify state in production and are not easily reversible.</div>
            </div>
            <div class="chapter-diagram">
              <pre>
User Query
    â†“
[Phase 1: Routing]
    Agent Router â†’ chooses agent
    â†“
[Phase 2: Context]
    Context Provider â†’ reduced payload
    â†“
[Phase 3: Planning]
    Agent â†’ Realization Package
    â†“ HALT
[Phase 4: Approval Gate]
    Summary in human language
    AskUserQuestion â†’ Approve / Reject / Other
    â”œâ”€ Approved? â†’ continue
    â””â”€ Rejected? â†’ HALT
    â†“
[Phase 5: Realization]
    Execute + Verify
    â†“
[Phase 6: State Update]
    update project-context.json
    update tasks.md
    report next steps
              </pre>
            </div>
          </div>
        </section>

        <!-- Chapter 4 -->
        <section class="chapter" id="cap-4">
          <div class="chapter-layout">
            <div class="chapter-text">
              <h2>Chapter 4: Layered Security</h2>
              <h3>Settings and permissions: security tiers and hooks</h3>
              <div class="blockquote">Automation rarely stops due to lack of capability; it almost always stops where our trust ends.</div>
              <p>The problem wasn't automation itself. It was that I was creating unnecessary friction where I didn't need it. A predictable workflow requires two simultaneous pillars:</p>
              <p><strong>Agility</strong>, where risk is null (queries, validations).</p>
              <p><strong>Control</strong>, where risk is irreversible (deployments, deletions).</p>
              <p>Without this discrimination, you end up with noise or danger. <strong>Solution?</strong></p>

              <h3>1. Security Tiers (T0â€“T3)</h3>
              <p>I classified all operations into four risk levels: <strong>T0</strong> reads, <strong>T1</strong> validations, <strong>T2</strong> local changes/dryâ€‘run, and <strong>T3</strong> operations that write to real environments and require Approval Gate.</p>

              <h3>2. Hooks: the system's guardians</h3>
              <p><strong>pre_tool_use.py:</strong> Intercepts all commands before execution and decides if it's safe before executing it.</p>
              <p><strong>post_tool_use.py:</strong> Logs what happened after executing the command.</p>
              <p><strong>subagent_stop.py:</strong> Every time an agent closes a session, it generates a complete report.</p>

              <h3>3. Settings: Allow, Ask, Deny</h3>
              <p>With tiers and hooks in place, the orchestrator was finally armored: any command passed through a filter before touching a real environment. It was time for agents to stop just executing commands for me; it was time to delegate complete tasks to them. For that I had to go to the root: edit the <code>.claude/settings.json</code> file.</p>
              <p>There I define how Claude Code reacts to each command that comes from the prompt: <strong>Deny</strong> marks what should never be executed, <strong>Ask</strong> stops the flow and asks me for explicit confirmation for sensitive operations, and <strong>Allow</strong> lets safe reads and actions pass without friction.</p>
              <p>The result is simple: the system's speed is no longer limited by what agents can do, but by what I decide to allow. When my confidence changes, I don't rewrite the entire system; I adjust the settings.</p>
            </div>
            <div class="chapter-diagram pre-split">
              <div class="diagram-block tiers">
                <pre>
Security Tiers
â”Œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Tierâ”‚ Type          â”‚ Quick example               â”‚
â”œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ T0 â”‚ Readâ€‘Only     â”‚ get, show, status           â”‚
â”‚ T1 â”‚ Validation    â”‚ validate, lint, --dryâ€‘run   â”‚
â”‚ T2 â”‚ Dryâ€‘Run/Local â”‚ plan, local edits           â”‚
â”‚ T3 â”‚ Write Ops     â”‚ apply, push, deploy         â”‚
â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                </pre>
              </div>
              <div class="diagram-block flow">
                <pre>
Execution flow
User prompt
    â†“
Settings (Allow / Ask / Deny)
    â†“
pre_tool_use.py   (security)
    â†“
Bash / command
    â†“
post_tool_use.py  (audit log)
    â†“
subagent_stop.py  (session report)
                </pre>
              </div>
            </div>
          </div>
        </section>

        <hr />

        <!-- Synthesis -->
        <section class="chapter" id="cap-6">
          <h2>Chapter 5: Reflections, Synthesis, and the Path Forward</h2>
          <h3>What Works, What Doesn't, and Why It Matters</h3>
          <p>The tools are there. The guardrails are there. The system works. But building it taught me more about systems than about individual commands.</p>

          <p>If I've learned anything in all this madness, it's that this new technology isn't about writing more software, but about <strong>designing behaviors</strong>: systems that make decisions with context, with guardrails, and with a human who understands why they trust them. Each iteration made me ask less "what code to write" and more "what decisions do I want the system to make, with what context and under what limits."</p>

          <h3>Principles I take with me</h3>
          <ul>
            <li><strong>AI doesn't replace humans, it amplifies them.</strong> It allows me to explore more paths in less time, but that amplification only works if I maintain the same rigor I would have reviewing the work of a human team.</li>
            <li><strong>Context is not an information dump.</strong> It's deciding what each agent needs to know, no more, no less. <code>project-context.json</code>, contracts, and the Context Provider exist so agents work with useful context, not noise.</li>
            <li><strong>A clear workflow is worth more than "more intelligence."</strong> The six phases (routing, context, planning, approval, realization, update) matter more than having a larger model. Without clear phases, the system becomes unpredictable.</li>
            <li><strong>Security is part of architecture, not a patch at the end.</strong> Tiers T0â€“T3, hooks, and Allow/Ask/Deny settings aren't "implementation details": they're the foundation for being able to trust a system that executes real commands in real environments.</li>
            <li><strong>There's no final version, only versions good enough to learn something new.</strong> The system changes with each use. What matters isn't "closing it," but having the ability to observe it, measure it, and redesign it without fear.</li>
          </ul>

          <h3>What's next?</h3>
          <p>The system is already packaged as NPM and ready for <code>npx</code>, but not yet published. What comes now is summarized in three fronts:</p>
          <ul>
            <li><strong>Deepen Clarify (Phase 0):</strong> improve ambiguity detection and automatic questions that guide the user.</li>
            <li><strong>Rethink planning (Specâ€‘Kit and beyond):</strong> review how tasks and plans are born to better align them with the six-phase workflow and real agent usage.</li>
            <li><strong>Make task management visible:</strong> explore whether the best option is to integrate JIRA/Linear or opt for a custom system that speaks the same language as the agents.</li>
          </ul>

        </section>
      </article>
      <div class="footer">
        <p lang="es" data-lang-section="es">El verdadero lÃ­mite de la automatizaciÃ³n no estÃ¡ en las mÃ¡quinas, sino en lo que estamos dispuestos a dejar que hagan por nosotros. Â© Jorge Aguilar</p>
        <p lang="en" data-lang-section="en" hidden>The true limit of automation isn't in the machines, but in what we're willing to let them do for us. Â© Jorge Aguilar</p>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const themeBtn = document.getElementById('theme-btn');
      const langBtn = document.getElementById('lang-btn');
      const langText = langBtn.querySelector('.lang-text');
      const pageTitle = document.getElementById('page-title');
      const languageSections = document.querySelectorAll('[data-lang-section]');
      const languageStorageKey = 'agentic-workflows-active-lang';

      themeBtn.addEventListener('click', toggleTheme);
      langBtn.addEventListener('click', toggleLanguage);

      loadTheme();
      initializeLanguage();
      bindSystemThemeListener();

      function toggleTheme() {
        const body = document.body;
        const themeIcon = document.querySelector('.theme-icon');
        const themeText = document.querySelector('.theme-text');

        const currentTheme = body.getAttribute('data-theme');
        const newTheme = currentTheme === 'day' ? 'night' : 'day';

        body.setAttribute('data-theme', newTheme);

        if (newTheme === 'night') {
          themeIcon.textContent = 'ğŸŒ™';
          themeText.textContent = 'Modo DÃ­a';
        } else {
          themeIcon.textContent = 'â˜€ï¸';
          themeText.textContent = 'Modo Noche';
        }

        localStorage.setItem('theme', newTheme);
      }

      function loadTheme() {
        const savedTheme = localStorage.getItem('theme');
        const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'night' : 'day';
        const theme = savedTheme || systemTheme;

        document.body.setAttribute('data-theme', theme);

        const themeIcon = document.querySelector('.theme-icon');
        const themeText = document.querySelector('.theme-text');

        if (theme === 'night') {
          themeIcon.textContent = 'ğŸŒ™';
          themeText.textContent = 'Modo DÃ­a';
        } else {
          themeIcon.textContent = 'â˜€ï¸';
          themeText.textContent = 'Modo Noche';
        }
      }

      function bindSystemThemeListener() {
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        const handler = () => {
          if (!localStorage.getItem('theme')) {
            loadTheme();
          }
        };

        if (typeof mediaQuery.addEventListener === 'function') {
          mediaQuery.addEventListener('change', handler);
        } else if (typeof mediaQuery.addListener === 'function') {
          mediaQuery.addListener(handler);
        }
      }

      function toggleLanguage() {
        const current = document.body.getAttribute('data-lang') || 'es';
        const next = current === 'en' ? 'es' : 'en';
        applyLanguage(next);
      }

      function initializeLanguage() {
        const savedLang = localStorage.getItem(languageStorageKey);
        const initialLang = savedLang === 'en' ? 'en' : 'es';
        applyLanguage(initialLang);
      }

      function applyLanguage(lang) {
        document.body.setAttribute('data-lang', lang);
        document.documentElement.lang = lang;

        languageSections.forEach((section) => {
          const sectionLang = section.getAttribute('data-lang-section');
          section.hidden = sectionLang !== lang;
        });

        updateLangButtonLabel(lang);
        localStorage.setItem(languageStorageKey, lang);
        if (pageTitle) {
          const titleText = lang === 'es' ? pageTitle.dataset.textEs : pageTitle.dataset.textEn;
          pageTitle.textContent = titleText;
        }
      }

      function updateLangButtonLabel(activeLang) {
        if (activeLang === 'es') {
          langText.textContent = 'EN';
          langBtn.setAttribute('aria-label', 'Cambiar a inglÃ©s');
        } else {
          langText.textContent = 'ES';
          langBtn.setAttribute('aria-label', 'Switch to Spanish');
        }
      }
    })();
  </script>
</body>
</html>


